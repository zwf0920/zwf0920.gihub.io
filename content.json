{"meta":{"title":"zwf0920","subtitle":"感受生活，拥抱世界","description":"zwf0920个人站，主要涉及java后端和框架技术","author":"zwf0920","url":"https://zwf0920.github.io","root":"/"},"pages":[{"title":"分类","date":"2020-05-09T20:48:48.630Z","updated":"2020-05-09T20:48:48.630Z","comments":true,"path":"categories/index.html","permalink":"https://zwf0920.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-05-09T20:48:57.553Z","updated":"2020-05-09T20:48:57.553Z","comments":true,"path":"tags/index.html","permalink":"https://zwf0920.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"使用反射在泛型为Integer的ArrayList中添加String类型的数据","slug":"使用反射在泛型为Integer的ArrayList中添加String类型的数据","date":"2020-05-17T16:00:00.000Z","updated":"2020-05-18T23:56:47.017Z","comments":true,"path":"2020/05/18/使用反射在泛型为Integer的ArrayList中添加String类型的数据/","link":"","permalink":"https://zwf0920.github.io/2020/05/18/使用反射在泛型为Integer的ArrayList中添加String类型的数据/","excerpt":"","text":"使用反射在泛型为Integer的ArrayList中添加String类型的数据记录一下一个面试题，这道题一看到我有点懵，照常理类型为Integer怎么能添加String类型。但是想到反射是可以打破这种限制的。笔试的时候我没写出来，在笔试完后我在idea上试了一下，代码如下： 12345678910111213import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.ArrayList;public class Test &#123; public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123; ArrayList&lt;Integer&gt; list =new ArrayList&lt;&gt;(); Method method = list.getClass().getMethod(\"add\",Object.class); method.invoke(list,\"字符串\"); method.invoke(list,\"字符串2\"); System.out.println(list); &#125;&#125; 输出结果如下: [字符串, 字符串2] 搜索了一些资料：泛型只在编译期有效,在运行期会被擦除掉，运行期间获取Class，反射执行add方法。","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://zwf0920.github.io/tags/面试题/"}]},{"title":"MySQL使用参考","slug":"MySql使用参考","date":"2020-04-16T16:00:00.000Z","updated":"2020-05-10T12:06:56.912Z","comments":true,"path":"2020/04/17/MySql使用参考/","link":"","permalink":"https://zwf0920.github.io/2020/04/17/MySql使用参考/","excerpt":"","text":"管理数据库结构数据库 1、创建数据库 1create database 数据库名 default character set utf8 collate utf8_general_ci; default character set utf8：设置数据库的编码方式，支持中文。 collate utf8_general_ci：设置数据库的校验字符集 utf8_general_ci：不区分大小写 utf8_bin：区分大小写 2、删除数据库 1drop database 数据库名; 3、查看数据库 1show databases; 4、选择数据库 1use 数据库名; 数据表 1、创建数据表 1234create table 表名( id int, name varchar(11)); 2、删除数据表 1drop table 表名; 3、查看数据库所有的表 1show tables; 4、查看表结构 1desc 表名; 5、修改数据表的结构 新增一个字段 123alter table 表名 add 字段名 数据类型;example:alter table user add name varchar(20); 删除一个字段 1alter table 表名 drop 字段名; 修改一个字段 123ALTER TABLE 表名 CHANGE 原字段名 新字段名 字段类型 约束条件example: ALTER TABLE user10 CHANGE test test1 CHAR(32) NOT NULL DEFAULT '123'; 数据 1、添加数据 123insert into 表名(字段名1,字段名2...) values(值1,值2...);example：insert into user(id,name) values(1,\"张三\"); 2、查询数据 1select * from 表名; 3、修改数据 1update 表名 set 字段名 = 修改值; 4、删除数据 1delete from 表名; SQL 函数SQL 提供了很多函数，可以完成很复杂的功能，但是一般实际开发中不会用 SQL 来完成复杂的业务操作， SQL 只是一个简单的存储机制，会消耗大量的资源。 Java 程序来完成相对复杂的操作，SQL 只是负责对数据进行保存和管理。 数学函数： abs(num) 求绝对值 1select abs(score) from user where id = 1; floor(num) 返回小于 num 的最大整数 1select floor(score) from user where id = 3; ceil(num) 返回大于 num 的最小整数 1select ceil(score) from user where id = 2; 字符串函数 insert(s1,index,len,s2) s1 中 index 位置开始，长度为 len 的字符替换为 s2 1select insert(name,1,2,\"小红\") from user where id = 1; upper(),ucase() 将字母值变为大写 1select ucase(name) from user where id = 4; lower(),lcase() 将字母值变为小写 1select lcase(name) from user where id = 4; left(s,len) 返回 s 字符串的前 len 个字符 1select left(name,1) from user where id = 1; right(s,len) 返回 s 字符串的后 len 个字符 1select right(name,1) from user where id = 1; substring(s, index,len) 截取 s 字符串，从 index 位置开始，长度为 len 1select substring(name,2,2) from user where id = 1; reverse() 反序输出 1select reverse(name) from user where id = 1; 日期函数： curdate()、current_date() 获取当前日期 1select current_date(); curtime()、current_time() 获取当前时间 1select curtime(); now() 获取当前日期+时间 1select now(); datediff(d1,d2) 获取 d1 和 d2 之间相隔的天数 1select datediff(\"2019-02-11\",\"2017-03-16\"); adddate(d,n) 返回 d 日期之后 n 天的日期 1select adddate(\"2019-02-11\",600); subdate(d,n) 返回 d 日期之前 n 天的日期 1select subdate(\"2019-02-11\",600); 聚合函数 count() 根据某个字段统计总记录数 1select count(*) from user; sum() 计算某个字段值的总和 1select sum(score) from user; avg() 求某个字段总和的平均值 1select avg(score) from user; max() 求某个字段的最大值 1select max(score) from user; min() 求某个字段的最小值 1select min(score) from user; MySQL 运算符 1、算术运算符 ​ 执行运算符：加减乘除 1select score/10 from user where id = 3; ​ 比较运算符：大于、等于、小于、不等于 1select score != 100 from user where id = 3; ​ 逻辑运算符：与 或 非 1select score &lt; 100 &amp;&amp; score &gt; 60 from user where id = 3; 2、特殊运算符 is null 判断数据是否为空 1select name is null from user where id = 5; between and 判断值是否在某个区间之内 1select name,score between 90 and 100 from user; 1select name,score &gt;= 90 &amp;&amp; score &lt;= 100 from user; in 判断值是否在某个确定值的集合内 1select name,score from user where id in (1,2,3); 1select name,score from user where id = 1 or id = 2 || id = 3; like 模糊查询 以”水”开头 1select * from easybuy_product where name like '水%'; 以”水”结尾 1select * from easybuy_product where name like '%水'; 包含”水” 1select * from easybuy_product where name like '%水%'; 长度为2，一个”_”表示一个长度 1select * from easybuy_product where name like '__'; 包含”水”，同时长度为 3 1select * from easybuy_product where name like '_水_'; 以”水”开头，同时长度为3 1select * from easybuy_product where name like '水__'; 以”水”结尾，同时长度为3 1select * from easybuy_product where name like '__水'; 多表关联查询一对多关系 嵌套查询 1select * from address where uid = (select id from user where name = '李四'); 连接查询 内连接 1select u.name uname,u.score,a.name aname from user u inner join address a where u.name = \"张三\" and u.id = a.uid; 1select u.name uname,u.score,a.name aname from user u,address a where u.name = \"张三\" and u.id = a.uid; 外连接 左连接：左表所有数据和右表满足条件的数据 1select * from user u left join address a on u.id = a.uid and u.name = \"张三\"; 右连接：右表所有数据和左表满足条件的数据 1select * from user u right join address a on u.id = a.uid and u.name = \"张三\"; 多对多关系 123456789create table student( id int primary key auto_increment, name varchar(11));create table course( id int primary key auto_increment, name varchar(11)); 多对多关系的建立不能直接给两张参与的数据表设置主外键关联关系，需要创建第三张表，来间接促成两张表的多对多关系，中间表中存在两个外键，分别被两张目标表的主键约束，两张目标表都是主表，中间表是两张目标表的从表。 1234567create table student_course( id int primary key auto_increment, sid int, cid int, foreign key (sid) references student(id), foreign key (cid) references course(id)); 嵌套查询 1select * from student_course sc,course c,student s where c.id = sc.cid and s.id = sc.sid and sid = (select id from student where name = \"张三\"); 内连接查询 1select s.name sname,c.name cname from student s,course c,student_course sc where s.id = sc.sid and c.id = sc.cid; 去重 distinct 1select distinct s.name sname,c.name cname from student s,course c,student_course sc where s.id = sc.sid and c.id = sc.cid; 分页 limit index,length limit 本质上就是在截取查询到的结果集，index 是起始下标，length 是截取的长度。 1select * from user limit 0,10; 数据库索引 索引是一种特殊的数据库结构，可以用来快速查询数据库表中的特定记录，索引是提高数据库性能的重要方式，所有字段都可以添加索引。 索引包括：普通索引、唯一性索引、全文索引、单列索引、多列索引、空间索引。 使用索引可以提升检索数据的速度，但是创建和维护所以需要耗费大量的时间，索引需要占用大量的物理空间。 普通索引：不需要任何限制条件的索引，可在任意数据类型上创建。 唯一索引：索引的值必须唯一，比如主键索引。 全文索引：只能创建在 char varchar text 类型的字段上，查询数据量较大的字符串类型字段时，使用全文索引可以提高效率，InnoDB 存储引擎不支持全文索引。 单列索引：只对应一个字段的索引。 多列索引：在一张表的多个字段上创建一个索引，查询时使用第一个字段，即可触发索引。 空间索引：只能建立在空间数据类型上（GIS），InnoDB 存储引擎不支持空间索引。 索引 index普通索引、唯一性索引、全文索引、单列索引、多列索引、空间索引。 1、添加索引 1alter table 表名 add index 索引名(字段) 1create index 索引名 on 表名(字段) 2、删除索引 1alter table 表名 drop index 索引名 1drop index 索引名 on 表名 1select name,age from user where id = 10; where 后面的字段加索引，select 后面的字段不加索引。 事务 transaction将多条 SQL 作为一个整体，要么全执行，要么一条都不执行。 张三和李四各有1000块钱，张三借给李四500块钱，用数据库来体现这一场景。 原子性：多条 SQL 语句是一个整体，不可再分割。 一致性：SQL 语句执行前后，数据库数据的值保持一致。 隔离性：一个事务的执行不能被其他事务所干扰。 持久性：一个事务一旦提交，数据库中数据的改变是永久的。 MySQL 是默认自动提交事务的，可以通过语句来查询是否开启了事务的自动提交 1show variables like 'autocommit'; 开启/关闭自动提交 1set autocommit = 1/0; 事务的操作： 1、开启事务 start transaction; 2、回滚 rollback; 3、提交 commit; 1234start transaction;update people set money = 500 where id = 1;update people set money = 1500 where id = 2;rollback; 1234start transaction;update people set money = 500 where id = 1;update people set money = 1500 where id = 2;commit; 视图 view数据库中一张虚拟的表，允许不同用户或应用程序以不同的方式查看同一张表中的数据。 创建视图： 1create view view_common as select id,name from people; 使用视图： 1select * from view_common; 删除视图： 1drop view view_common; 触发器 trigger触发器定义了一系列操作，可以在对指定的表进行插入、更新或者删除操作的同时自动执行这些预先定义好的操作。 触发器的优点 开发更快，因为触发器存储在数据库中，所以不必编写每个触发器在应用程序中执行的操作。 更容易维护，定义好触发器之后，访问目标表，会自动调用触发器。 业务全局实现，如果修改业务，只需要修改触发器即可，不需要修改业务代码。 触发器的分类： 前触发器：在更新、插入操作之前执行。 后触发器：在更新、插入、删除之后执行。 Before delete触发器：在删除之前执行。 Insted of 触发器：对复杂视图执行插入、更新和删除时执行。 123456create table tab1( tab1_id varchar(11));create table tab2( tab2_id varchar(11)); 创建触发器 123456create trigger t_afterinsert_on_tab1 after insert on tab1 for each row begin insert into tab2(tab2_id) values (new.tab1_id); end; 删除触发器 1drop trigger t_afterinsert_on_tab1; 123456create trigger t_afterdelete_on_tab1 after delete on tab1 for each row begin delete from tab2 where tab2_id = old.tab1_id; end; 1drop trigger t_afterdelete_on_tab1; 存储过程 procedure存储过程是一组为了完成特定功能的 SQL 语句的集合，经编译后存储在数据库中，用户通过指定存储过程的名称并给出参数来执行。 一次编写，多次调用，避免开发人员重复编写相同的 SQL，存储过程是在数据库存储和执行的。可以减少客户端和服务器之间的数据传输，提高效率。 优点： 模块化的程序设计，只需要创建一次存储过程，以后就可以在程序中调用该存储过程任意次。 执行速度更快，如果某操作需要执行大量的 SQL 语句或重复执行 SQL 语句，存储过程比普通的 SQL 语句执行更快。 更好的安全机制，对于没有权限执行存储过程的用户，也可以授权他们执行存储过程。 创建存储过程 1create produce 存储过程名称(参数列表) routine_body 参数列表：参数数据类型，参数名称，输入输出类型（in 入参，out 出参） 12345678910create procedure add_name(in target int)begin declare name varchar(20); if target = 1 then set name = \"MySQL\"; else set name = \"Java\"; end if; insert into user(name) values (name);end; 1call add_name(2); 1drop procedure add_name; 1234create procedure count_of_user(out count_num int)begin select count(*) into count_num from user;end; 12call count_of_user(@count_num);select @count_num; 1drop procedure count_of_user; 存储过程存储过程是一组为了完成特定功能的 SQL 语句集合，经过编译后存储在数据库中，用户通过指定存储过程的名称以及参数来执行相应的存储过程。 一次编写，多次调用，避免开发人员重复编写相同的 SQL 语句，存储过程是在数据库中存储和执行的，可以减少客户端和服务端之间的数据传输，从而提高效率。 优点 模块化的程序设计，只需要创建一次存储过程，以后就可以在程序中调用该存储过程任意次。 执行速度更快，如果某个操作需要执行大量的 SQL 语句或者需要重复执行 SQL 语句，存储过程比 SQL 语句执行的更快。 更好的安全机制，对于没有权限执行存储过程的用户，也可以授权他们执行存储过程。 具体使用1create procedure 存储过程名称 (参数列表) routine_body 参数列表由 3 部分组成：输入输出类型，参数名称，参数数据类型。 in 表示入参，从外部调用方传给存储过程内部，相当于 Java 方法中的参数。 out 表示出参，存储过程内部返回给外部调用者的值，相当于 Java 方法中的返回值。 routine_body SQL 代码的内容，begin/end 来标识代码的开始和结束。 创建存储过程 12345678910create procedure add_name(in target int)begin declare name varchar(20); if target = 1 then set name = \"MySQL\"; else set name = \"Java\"; end if; insert into test.student(name) values(name);end; 使用存储过程：call 存储过程名称(参数列表) 1call add_name(2); 删除存储过程：drop procedure 存储过程名称 1drop procedure add_name; 出参存储过程创建存储过程 1234create procedure count_of_student(out count_num int)begin select count(*) into count_num from test.student;end; 使用存储过程 12call count_of_student(@count_num);select @count_num; 流程控制语句： if 12345678create procedure example_if(in x int)begin if x = 1 then select id from student; elseif x = 2 then select name from student; end if;end; case 12345678create procedure example_case(in x int)begin case x when 1 then select id from student; when 2 then select name from student; when 3 then select score from student; end case;end; while 12345678910create procedure example_while(out sum int)begin declare i int default 1; declare s int default 0; while i&lt;=100 do set s = s+i; set i = i+1; end while; set sum = s;end;","categories":[{"name":"使用参考","slug":"使用参考","permalink":"https://zwf0920.github.io/categories/使用参考/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://zwf0920.github.io/tags/mysql/"}]},{"title":"SSM 框架配置文件","slug":"SSM 框架整合及其配置文件","date":"2020-04-09T07:36:37.000Z","updated":"2020-05-14T19:25:18.962Z","comments":true,"path":"2020/04/09/SSM 框架整合及其配置文件/","link":"","permalink":"https://zwf0920.github.io/2020/04/09/SSM 框架整合及其配置文件/","excerpt":"","text":"SSM 框架配置文件SpringSpring 是 Java 开发的行业标准 Spring MVCSpring Web MVC，基于 Spring 实现 MVC 设计模式的框架。 MyBatis当前主流的 ORM 框架，完成 JDBC 的封装，持久层的解决方案。 SSM 框架整合中，Spring、Spring MVC、MyBatis 分别负责不同的业务模块，共同来完成企业级项目开发的需求。 Spring MVC 负责实现 MVC 设计模式。 MyBatis 负责持久层的交互。 Spring 管理 Spring MVC 和 MyBatis：IoC 容器负责 Spring MVC 和 MyBatis 相关对象的创建和依赖注入，AOP 负责事务管理。 开发步骤1、创建 Maven Web 工程，pom.xml 添加相关依赖，Spring MVC、MyBatis、Spring、Spring 整合 MyBatis。 2、web.xml 配置开启 Spring（监听）、Spring MVC（DispatcherServlet），设置字符编码过滤器，加载静态资源，Spring MVC 会拦截所有请求，导致 JSP 页面中 JS、CSS、图片等静态资源无法正常加载，将静态资源的请求交给项目的默认拦截器。 3、配置各个框架的 XML 文件。 applicationContext.xml：Spring 的配置文件。 dbconfig.properties：数据库配置文件。 mybatis-config.xml：MyBatis 配置文件。 springmvc.xml：Spring MVC 配置文件。 pom.xml:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.luffy&lt;/groupId&gt; &lt;artifactId&gt;70&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;70 Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- SpringMVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring JDBC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring AOP --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;5.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MyBatis整合 Spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt; &lt;!-- C3P0 --&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSTL --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- ServletAPI --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.8&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;!-- 读取xml --&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;*.xml&lt;/include&gt; &lt;include&gt;*.properties&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;finalName&gt;70&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; web.xml:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- Spring --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- Spring MVC --&gt; &lt;servlet&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 加载静态资源 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.js&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.css&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; applicationContext.xml:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!-- 加载外部文件 --&gt; &lt;!-- 这样就可以用类似EL表达式的方式 读取dbconfig.properties中的内容--&gt; &lt;context:property-placeholder location=\"classpath:dbconfig.properties\"&gt;&lt;/context:property-placeholder&gt; &lt;!-- 数据源 --&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.user&#125;\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"&gt;&lt;/property&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driverClass&#125;\"&gt;&lt;/property&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.jdbcUrl&#125;\"&gt;&lt;/property&gt; &lt;property name=\"initialPoolSize\" value=\"5\"&gt;&lt;/property&gt; &lt;property name=\"maxPoolSize\" value=\"10\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- SqlSessionFactory --&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;!-- 数据源 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;!-- Mapper.xml --&gt; &lt;property name=\"mapperLocations\" value=\"classpath:com/luffy/repository/*.xml\"&gt;&lt;/property&gt; &lt;!-- MyBatis全局配置文件 --&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 扫描MyBatis Mapper接口 --&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.luffy.repository\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置事务管理 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置事务如何切入 --&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"*\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 开启基于注解的事务 --&gt; &lt;aop:config&gt; &lt;aop:pointcut id=\"txPoint\" expression=\"execution(* com.luffy.service.impl.*.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPoint\"&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt;&lt;/beans&gt; dbconfig.properties：1234jdbc.jdbcUrl=jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=UTF-8jdbc.driverClass=com.mysql.cj.jdbc.Driverjdbc.user=rootjdbc.password=123456 mybatis-config.xml：123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;!-- 打印SQL --&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\" /&gt; &lt;/settings&gt; &lt;!-- 提取包名 --&gt; &lt;typeAliases&gt; &lt;package name=\"com.luffy.entity\"/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; springmvc.xml：12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd\"&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;context:component-scan base-package=\"com.luffy\"&gt;&lt;/context:component-scan&gt; &lt;!-- 视图解析 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; tips:在springboot中xml的代码可以用注解的方式和yaml实现去xml,如视图解析可以如下配置:123456789@Configurationpublic class AppConfig &#123; @Bean // 配置JSP视图解析器 public ViewResolver viewResolver() &#123; InternalResourceViewResolver resolver = new InternalResourceViewResolver(); resolver.setPrefix(\"/\"); resolver.setSuffix(\".jsp\"); return resolver; &#125;&#125; (@Configuration可理解为用spring的时候xml里面的标签,@Bean可理解为用spring的时候xml里面的标签。)","categories":[{"name":"使用参考","slug":"使用参考","permalink":"https://zwf0920.github.io/categories/使用参考/"}],"tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"https://zwf0920.github.io/tags/Spring-MVC/"}]},{"title":"Thymeleaf 常用标签","slug":"Thymeleaf 常用标签","date":"2020-04-08T16:00:00.000Z","updated":"2020-05-10T12:22:12.436Z","comments":true,"path":"2020/04/09/Thymeleaf 常用标签/","link":"","permalink":"https://zwf0920.github.io/2020/04/09/Thymeleaf 常用标签/","excerpt":"","text":"Thymeleaf 常用标签Thymeleaf 全部是嵌入到 HTML 标签内部去使用。 th:text 用于文本显示，将业务数据的值填充到 HTML 标签中 th:if 用来做条件判断，对业务数据的值进行判断，如果成立则显示内容，否则不显示。 1234567@GetMapping(\"/index\")public ModelAndView index()&#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName(\"index\"); modelAndView.addObject(\"score\",90); return modelAndView;&#125; 12&lt;p th:if=\"$&#123;score&gt;=90&#125;\"&gt;优秀&lt;/p&gt;&lt;p th:if=\"$&#123;score&lt;90&#125;\"&gt;良好&lt;/p&gt; th:unless 用来做条件判断，逻辑与 th:if 刚好相反，如果条件不成立显示，条件成立不显示。 th:switch th:case th:switch、th:case 两个标签需要结合起来使用，用作多条件等值判断，逻辑与 Java 中的 switch-case 一致，当 switch 中的业务数据值等于某个 case 值时，就显示该 case 对应的内容。 1234567@GetMapping(\"/index\")public ModelAndView index()&#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName(\"index\"); modelAndView.addObject(\"id\",2); return modelAndView;&#125; 12345&lt;div th:switch=\"$&#123;id&#125;\"&gt; &lt;p th:case=\"1\"&gt;张三&lt;/p&gt; &lt;p th:case=\"2\"&gt;李四&lt;/p&gt; &lt;p th:case=\"3\"&gt;王五&lt;/p&gt;&lt;/div&gt; th:action 用来指定请求的 URL，相当于 form 表单中的 action 属性。 12345&lt;form th:action=\"@&#123;/login&#125;\" method=\"post\"&gt; 用户名：&lt;input type=\"text\" name=\"name\"/&gt;&lt;br/&gt; 密码：&lt;input type=\"password\" name=\"password\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"登录\"/&gt;&lt;/form&gt; th:each 1234567891011@GetMapping(\"/each\")public ModelAndView each()&#123; List&lt;User&gt; list = new ArrayList&lt;&gt;(); list.add(new User(1L,\"张三\",0)); list.add(new User(2L,\"李四\",1)); list.add(new User(3L,\"王五\",0)); ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName(\"test\"); modelAndView.addObject(\"list\",list); return modelAndView;&#125; 12345678910111213&lt;table&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=\"user:$&#123;list&#125;\"&gt; &lt;td th:text=\"$&#123;user.id&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;user.name&#125;\"&gt;&lt;/td&gt; &lt;td th:if=\"$&#123;user.gender == 1&#125;\"&gt;男&lt;/td&gt; &lt;td th:if=\"$&#123;user.gender == 0&#125;\"&gt;女&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; th:value 用来给标签赋值 1234567@GetMapping(\"/value\")public ModelAndView value()&#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName(\"test\"); modelAndView.addObject(\"value\",\"Spring Boot\"); return modelAndView;&#125; 1&lt;input type=\"text\" th:value=\"$&#123;value&#125;\"/&gt; th:src 用来引入静态资源，相当于 HTML 原生标签 img、script 的 src 属性。 1234567@GetMapping(\"/src\")public ModelAndView src()&#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName(\"test\"); modelAndView.addObject(\"src\",\"/1.png\"); return modelAndView;&#125; 1&lt;img th:src=\"$&#123;src&#125;\"&gt; 12$&#123;src&#125; //需要Handler将具体的路径传入到前端 @&#123;/1.png&#125; //Handler不需要传入具体的路径，只需要做映射，解析th标签 只要前端页面使用了 th，则必须通过 Handler 映射才能正确解析。 th:href 1234567@GetMapping(\"/href\")public ModelAndView href()&#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName(\"test\"); modelAndView.addObject(\"href\",\"https://spring.io/projects/spring-boot\"); return modelAndView;&#125; 12$&#123;href&#125; //需要Handler传值@&#123;http://www&#125; //不需要Handler传值 以上两种方式必须通过 Handler 映射才能解析，通 th:src th:selected 用来给 HTML 元素设置选中，条件成立则选中，否则不选中。 123456789101112@GetMapping(\"/selected\")public ModelAndView selected()&#123; List&lt;User&gt; list = new ArrayList&lt;&gt;(); list.add(new User(1L,\"张三\",1)); list.add(new User(2L,\"李四\",0)); list.add(new User(3L,\"王五\",1)); ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName(\"test\"); // modelAndView.addObject(\"list\",list); modelAndView.addObject(\"name\",\"李四\"); return modelAndView;&#125; 123456&lt;select&gt; &lt;!-- &lt;option th:each=\"user:$&#123;list&#125;\" th:text=\"$&#123;user.name&#125;\" th:selected=\"$&#123;user.name == name&#125;\"&gt;&lt;/option&gt;--&gt; &lt;option th:selected=\"$&#123;name=='张三'&#125;\"&gt;张三&lt;/option&gt; &lt;option th:selected=\"$&#123;name=='李四'&#125;\"&gt;李四&lt;/option&gt; &lt;option th:selected=\"$&#123;name=='王五'&#125;\"&gt;王五&lt;/option&gt;&lt;/select&gt; th:attr 用来给 HTML 标签的任意属性赋值。 1234567@GetMapping(\"/attr\")public ModelAndView attr()&#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName(\"test\"); modelAndView.addObject(\"attr\",\"Spring Boot\"); return modelAndView;&#125; 1&lt;input th:attr=\"value=$&#123;attr&#125;\"/&gt; Thymeleaf 对象Thymeleaf 支持直接访问 Servlet Web 原生资源，即 HttpServletRequest、HttpServletResponse、HttpSession、ServletContext 对象。 #request：获取 HttpServletRequest 对象 #response：获取 HttpServletResponse 对象 #session：获取 HttpSession 对象 #servletContext：获取 ServletContext 对象 1234567@GetMapping(\"/servlet\")public String servlet(HttpServletRequest request)&#123; request.setAttribute(\"value\",\"request\"); request.getSession().setAttribute(\"value\",\"session\"); request.getServletContext().setAttribute(\"value\",\"servletContext\"); return \"test\";&#125; 1234&lt;p th:text=\"$&#123;#request.getAttribute('value')&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;#session.getAttribute('value')&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;#servletContext.getAttribute('value')&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;#response&#125;\"&gt;&lt;/p&gt; Thymeleaf 可以直接访问 session，通过 ${session.name} 可以直接取值。 12345678@GetMapping(\"/session\")public ModelAndView session(HttpSession session)&#123; session.setAttribute(\"name\",\"张三\"); ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName(\"test\"); modelAndView.addObject(\"name\",\"李四\"); return modelAndView;&#125; 1234&lt;p th:text=\"$&#123;name&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;#request.getAttribute('name')&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;session.name&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;#session.getAttribute('name')&#125;\"&gt;&lt;/p&gt; Thymeleaf 内置对象 dates：日期格式化内置对象，参照 java.util.Date 的使用。 calendars：日期操作内置对象，参照 java.util.Calendar 的使用。 numbers：数字格式化内置对象。 strings：字符串格式化内置对象，参照 java.lang.String 的使用。 bools：boolean 类型内置对象。 arrays：数组操作内置对象，参照 java.utils.Arrays 的使用。 lists：List 集合内置对象，参照 java.util.List 的使用。 sets：Set 集合内置对象，参照 java.util.Set 的使用。 maps：Map 集合内置对象，参照 java.util.Map 的使用。 1234567891011121314151617181920212223242526272829@GetMapping(\"/utility\")public ModelAndView utility()&#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName(\"test\"); modelAndView.addObject(\"date\",new Date()); Calendar calendar = Calendar.getInstance(); calendar.set(2019,1,1); modelAndView.addObject(\"calendar\",calendar); modelAndView.addObject(\"number\",0.06); modelAndView.addObject(\"string\",\"Spring Boot\"); modelAndView.addObject(\"boolean\",true); modelAndView.addObject(\"array\", Arrays.asList(\"张三\",\"李四\",\"王五\")); List&lt;User&gt; list = new ArrayList&lt;&gt;(); list.add(new User(1L,\"张三\",1)); list.add(new User(2L,\"李四\",0)); list.add(new User(3L,\"王五\",1)); modelAndView.addObject(\"list\",list); Set&lt;User&gt; set = new HashSet&lt;&gt;(); set.add(new User(1L,\"张三\",1)); set.add(new User(2L,\"李四\",0)); set.add(new User(3L,\"王五\",1)); modelAndView.addObject(\"set\",set); Map&lt;Long,User&gt; map = new HashMap&lt;&gt;(); map.put(1L,new User(1L,\"张三\",1)); map.put(2L,new User(2L,\"李四\",0)); map.put(3L,new User(3L,\"王五\",1)); modelAndView.addObject(\"map\",map); return modelAndView;&#125; 1234567891011121314151617date格式化：&lt;span th:text=\"$&#123;#dates.format(date,'yyyy-MM-dd')&#125;\"&gt;&lt;/span&gt;&lt;br/&gt;当前日期：&lt;span th:text=\"$&#123;#dates.createToday()&#125;\"&gt;&lt;/span&gt;&lt;br/&gt;当前时间：&lt;span th:text=\"$&#123;#dates.createNow()&#125;\"&gt;&lt;/span&gt;&lt;br/&gt;calendar格式化：&lt;span th:text=\"$&#123;#calendars.format(calendar,'yyyy-MM-dd')&#125;\"&gt;&lt;/span&gt;&lt;br/&gt;number百分比格式化：&lt;span th:text=\"$&#123;#numbers.formatPercent(number,2,2)&#125;\"&gt;&lt;/span&gt;&lt;br/&gt;string是否为空：&lt;span th:text=\"$&#123;#strings.isEmpty(string)&#125;\"&gt;&lt;/span&gt;&lt;br/&gt;string长度：&lt;span th:text=\"$&#123;#strings.length(string)&#125;\"&gt;&lt;/span&gt;&lt;br/&gt;string拼接：&lt;span th:text=\"$&#123;#strings.concat('Hello World',string)&#125;\"&gt;&lt;/span&gt;&lt;br/&gt;boolean是否为true：&lt;span th:text=\"$&#123;#bools.isTrue(boolean)&#125;\"&gt;&lt;/span&gt;&lt;br/&gt;arrays的长度：&lt;span th:text=\"$&#123;#arrays.length(array)&#125;\"&gt;&lt;/span&gt;&lt;br/&gt;arrays是否包含张三：&lt;span th:text=\"$&#123;#arrays.contains(array,'张三')&#125;\"&gt;&lt;/span&gt;&lt;br/&gt;list是否为空：&lt;span th:text=\"$&#123;#lists.isEmpty(list)&#125;\"&gt;&lt;/span&gt;&lt;br/&gt;list长度：&lt;span th:text=\"$&#123;#lists.size(list)&#125;\"&gt;&lt;/span&gt;&lt;br/&gt;set是否为空：&lt;span th:text=\"$&#123;#sets.isEmpty(set)&#125;\"&gt;&lt;/span&gt;&lt;br/&gt;set长度：&lt;span th:text=\"$&#123;#sets.size(set)&#125;\"&gt;&lt;/span&gt;&lt;br/&gt;map是否为空：&lt;span th:text=\"$&#123;#maps.isEmpty(map)&#125;\"&gt;&lt;/span&gt;&lt;br/&gt;map长度：&lt;span th:text=\"$&#123;#maps.size(map)&#125;\"&gt;&lt;/span&gt;","categories":[{"name":"使用参考","slug":"使用参考","permalink":"https://zwf0920.github.io/categories/使用参考/"}],"tags":[{"name":"Thymeleaf","slug":"Thymeleaf","permalink":"https://zwf0920.github.io/tags/Thymeleaf/"}]},{"title":"MyBatis 逆向工程","slug":"MyBatis 逆向工程","date":"2020-03-13T07:36:37.000Z","updated":"2020-05-10T12:40:50.955Z","comments":true,"path":"2020/03/13/MyBatis 逆向工程/","link":"","permalink":"https://zwf0920.github.io/2020/03/13/MyBatis 逆向工程/","excerpt":"","text":"MyBatis 逆向工程简化代码的开发 MyBatis 是一个”半自动化”的ORM框架，SQL 语句需要开发者自定义，这样做的好处是代码更加灵活，SQL 语句需要单独在 Mapper.xml 中定义，与 Mapper 接口相对应，使用 MyBatis 进行开发的基本配置： 1、实体类 2、Mapper 接口 3、Mapper.xml 如果参与业务的表太多，每张表的业务都需要自定义 SQL、创建实体类、Mapper 接口，开发步骤过于繁琐，很麻烦。 除了定义 SQL 语句，创建实体类和 Mapper 接口工作量并不大，没有涉及太多的业务逻辑，属于简单的重复性工作。 MyBatis 能否自动根据数据表结构，帮助开发者生成实体类、Mapper 接口、Mapper.xml ? 使用 MyBatis 逆向工程即可自动完成上述的需求。 什么是逆向工程？逆向工程是 MyBatis 提供的一种自动化配置方案，针对数据表自动生成 MyBatis 所需要的各种资源，包括实体类、Mapper接口、Mapper.xml，但是逆向工程的缺陷在于只能针对单表进行操作，如果数据表之间有级联关系，逆向工程无法自动生成级联关系。 同时 MyBatis 逆向工程的灵活性较差，它可以根据当前的数据表结构自动生成相关资源，但是如果需求发生变化，需要对数据表结构进行修改，则之前自动创建的各种资源就不可再用，需要开发者手动删除，然后重新执行异常逆向工程的代码。 使用逆向工程，让 MyBatis 自动生成数据表对应的各种资源（实体类、Mapper 接口、Mapper.xml），可以大大减少开发者的工作量。 具体操作MyBatis 实现逆向工程的组件是 MyBatis Generator，简称 MBG，是专门为 MyBatis 框架定制的代码自动生成解决方案，MBG 可以根据数据表结构快速生成对应的 Mapper.xml、Mapper 接口、实体类，并且支持基本的 CURD 操作，但是业务逻辑相对复杂的操作需要开发者手动完成。 1、pom.xml 12345678910111213141516171819&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2、创建目标表 t_account，MBG 自动根据该表结构生成相关资源（实体类、Mapper 接口，Mapper.xml） 123456create table t_account( id int primary key auto_increment, username varchar(11), password varchar(11), age int); 3、创建 MBG 配置文件 generatorConfig.xml，核心配置有 jdbcConnection、javaModelGenerator、sqlMapGenerator、javaClientGenerator、table。 jdbcConnection 配置数据库连接信息。 javaModelGenerator 配置 JavaBean 的生成策略。 sqlMapGenerator 配置 SQL 映射文件生成策略。 javaClientGenerator 配置 Mapper 接口的生成策略。 table 配置要逆向解析的数据（tableName：表名，domainObjectName：对应的 JavaBean 名称） 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;&lt;generatorConfiguration&gt; &lt;context id=\"testTables\" targetRuntime=\"MyBatis3\"&gt; &lt;jdbcConnection driverClass=\"com.mysql.cj.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=UTF-8\" userId=\"root\" password=\"root\" &gt;&lt;/jdbcConnection&gt; &lt;javaModelGenerator targetPackage=\"com.luffy.entity\" targetProject=\"./src/main/java\"&gt;&lt;/javaModelGenerator&gt; &lt;sqlMapGenerator targetPackage=\"com.luffy.repository\" targetProject=\"./src/main/java\"&gt;&lt;/sqlMapGenerator&gt; &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"com.luffy.repository\" targetProject=\"./src/main/java\"&gt;&lt;/javaClientGenerator&gt; &lt;table tableName=\"t_account\" domainObjectName=\"Account\"&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 4、创建 GeneratorMain 类，执行自动生成资源的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.southwind.test;import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.exception.InvalidConfigurationException;import org.mybatis.generator.exception.XMLParserException;import org.mybatis.generator.internal.DefaultShellCallback;import java.io.File;import java.io.IOException;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;public class GeneratorMain &#123; public static void main(String[] args) &#123; List&lt;String&gt; warings = new ArrayList&lt;String&gt;(); boolean overwrite = true; String genCig = \"/generatorConfig.xml\"; File configFile = new File(GeneratorMain.class.getResource(genCig).getFile()); ConfigurationParser configurationParser = new ConfigurationParser(warings); Configuration configuration = null; try &#123; configuration = configurationParser.parseConfiguration(configFile); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (XMLParserException e) &#123; e.printStackTrace(); &#125; DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = null; try &#123; myBatisGenerator = new MyBatisGenerator(configuration,callback,warings); &#125; catch (InvalidConfigurationException e) &#123; e.printStackTrace(); &#125; try &#123; myBatisGenerator.generate(null); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Example 123456AccountExample accountExample = new AccountExample();accountExample.setOrderByClause(\"username desc\");accountExample.setDistinct(false);AccountExample.Criteria criteria = accountExample.createCriteria();criteria.andUsernameEqualTo(\"张三\");List&lt;Account&gt; accounts = accountExample.selectByExample(accountExample);","categories":[{"name":"使用参考","slug":"使用参考","permalink":"https://zwf0920.github.io/categories/使用参考/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://zwf0920.github.io/tags/mysql/"}]},{"title":"常用注解整理（非原创）","slug":"注解","date":"2020-02-10T07:36:37.000Z","updated":"2020-05-10T12:36:48.041Z","comments":true,"path":"2020/02/10/注解/","link":"","permalink":"https://zwf0920.github.io/2020/02/10/注解/","excerpt":"","text":"常用注解整理（非原创）笔者在代码学习中对注解这一块很陌生，于是在网上找了一些资料摘录下来，方便以后学习过程中查阅，如果有时间会对每个注解都写下使用方法和demo Java内置注解Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。 作用在代码的注解是 @Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。 @Deprecated - 标记过时方法。如果使用该方法，会报编译警告。 @SuppressWarnings - 指示编译器去忽略注解中声明的警告。 作用在其他注解的注解(或者说 元注解)是: @Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。 @Documented - 标记这些注解是否包含在用户文档中。 @Target - 标记这个注解应该是哪种 Java 成员。 @Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类) 从 Java 7 开始，额外添加了 3 个注解: @SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。 @FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。 @Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。 Spring mvc 常用注解一、组件型注解： @Component 在类定义之前添加@Component注解，他会被spring容器识别，并转为bean。 @Repository 对Dao实现类进行注解 (特殊的@Component) @Service 用于对业务逻辑层进行注解， (特殊的@Component) @Controller 用于控制层注解 ， (特殊的@Component) 以上四种注解都是注解在类上的，被注解的类将被spring初始话为一个bean，然后统一管理。 二、请求和参数型注解： @RequestMapping：用于处理请求地址映射，可以作用于类和方法上。 value：定义request请求的映射地址 method：定义地request址请求的方式，包括【GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE.】默认接受get请求，如果请求方式和定义的方式不一样则请求无法成功。 params：定义request请求中必须包含的参数值。 headers：定义request请求中必须包含某些指定的请求头，如：RequestMapping(value = “/something”, headers = “content-type=text/*”)说明请求中必须要包含”text/html”, “text/plain”这中类型的Content-type头，才是一个匹配的请求。 consumes：定义请求提交内容的类型。 produces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回 123451 @RequestMapping(value=\"/requestTest.do\",params = &#123;\"name=sdf\"&#125;,headers = &#123;\"Accept-Encoding=gzip, deflate, br\"&#125;,method = RequestMethod.GET)2 public String getIndex()&#123;3 System.out.println(\"请求成功\");4 return \"index\";5 &#125; 上面代码表示请求的方式为GET请求，请求参数必须包含name=sdf这一参数，然后请求头中必须有 Accept-Encoding=gzip, deflate, br这个类型头。 2.@RequestParam：用于获取传入参数的值 value：参数的名称 required：定义该传入参数是否必须，默认为true，（和@RequestMapping的params属性有点类似） 12345678910 1 @RequestMapping(&quot;/requestParams1.do&quot;) 2 public String requestParams1(@RequestParam(required = false) String name)&#123; 3 System.out.println(&quot;name = &quot;+name); 4 return &quot;index&quot;; 5 &#125; 6 @RequestMapping(&quot;/requestParams2.do&quot;) 7 public String requestParams2(@RequestParam(value = &quot;name&quot;,required = false) String names)&#123; 8 System.out.println(&quot;name = &quot;+names); 9 return &quot;index&quot;;10 &#125; 两种请入参方式是一样的，显示声明value的名称时，入参参数名和value一样，没有显示声明的话，像第一种方式声明的，入参参数名和函数参数变量名一样。 3.@PathViriable：用于定义路径参数值 value：参数的名称 required：定义传入参数是否为必须值 12345@RequestMapping(&quot;/&#123;myname&#125;/pathVariable2.do&quot;) public String pathVariable2(@PathVariable(value = &quot;myname&quot;) String name)&#123; System.out.println(&quot;myname = &quot;+name); return &quot;index&quot;; &#125; 这个路径声明了{myname}作为路径参数，那么这一段路径将为任意值，@PathVariable将可以根据value获取路径的值。 4.@ResponseBody：作用于方法上，可以将整个返回结果以某种格式返回，如json或xml格式。 1234561 @RequestMapping(\"/&#123;myname&#125;/pathVariable2.do\")2 @ResponseBody3 public String pathVariable2(@PathVariable(value = \"myname\") String name)&#123;4 System.out.println(\"myname = \"+name);5 return \"index\";6 &#125; 5.@ModelAttribute：用于把参数保存到model中，可以注解方法或参数，注解在方法上的时候，该方法将在处理器方法执行之前执行，然后把返回的对象存放在 session（前提时要有@SessionAttributes注解） 或模型属性中，@ModelAttribute(“attributeName”) 在标记方法的时候指定，若未指定，则使用返回类型的类名称（首字母小写）作为属性名称。 123456789101112 1 @ModelAttribute(\"user\") 2 public UserEntity getUser()&#123; 3 UserEntity userEntityr = new UserEntity(); 4 userEntityr.setUsername(\"asdf\"); 5 return userEntityr; 6 &#125; 7 8 @RequestMapping(\"/modelTest.do\") 9 public String getUsers(@ModelAttribute(\"user\") UserEntity user)&#123;10 System.out.println(user.getUsername());11 return \"/index\";12 &#125; 如上代码中，使用了@ModelAttribute(“user”)注解，在执行控制器前执行，然后将生成一个名称为user的model数据，在控制器中我们通过注解在参数上的@ModelAttribute获取参数，然后将model应用到控制器中，在jsp页面中我们同样可以使用它， 1231 &lt;body&gt;2 $&#123;user.username&#125;3 &lt;/body&gt; 6.@SessionAttributes 默认情况下Spring MVC将模型中的数据存储到request域中。当一个请求结束后，数据就失效了。如果要跨页面使用。那么需要使用到session。而@SessionAttributes注解就可以使得模型中的数据存储一份到session域中。配合@ModelAttribute(“user”)使用的时候,会将对应的名称的model值存到session中， 123456789101112131415161718 1 @Controller 2 @RequestMapping(&quot;/test&quot;) 3 @SessionAttributes(value = &#123;&quot;user&quot;,&quot;test1&quot;&#125;) 4 public class LoginController&#123; 5 @ModelAttribute(&quot;user&quot;) 6 public UserEntity getUser()&#123; 7 UserEntity userEntityr = new UserEntity(); 8 userEntityr.setUsername(&quot;asdf&quot;); 9 return userEntityr;10 &#125;11 12 @RequestMapping(&quot;/modelTest.do&quot;)13 public String getUsers(@ModelAttribute(&quot;user&quot;) UserEntity user ,HttpSession session)&#123;14 System.out.println(user.getUsername());15 System.out.println(session.getAttribute(&quot;user&quot;));16 return &quot;/index&quot;;17 &#125;18 &#125; 结合上一个例子的代码，加了@SessionAttributes注解，然后请求了两次，第一次session中不存在属性名为user的值，第二次请求的时候发现session中又有了，这是因为，这是因为第一次请求时，model数据还未保存到session中请求结束返回的时候才保存，在第二次请求的时候已经可以获取上一次的model了， Spring常用注解使用注解之前要开启自动扫描功能，其中base-package为需要扫描的包(含子包)。 1&lt;context:component-scan base-package=&quot;cn.test&quot;/&gt; @Configuration把一个类作为一个IoC容器，它的某个方法头上如果注册了@Bean，就会作为这个Spring容器中的Bean。@Scope注解 作用域@Lazy(true) 表示延迟初始化@Service用于标注业务层组件、@Controller用于标注控制层组件（如struts中的action）@Repository用于标注数据访问组件，即DAO组件。@Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。@Scope用于指定scope作用域的（用在类上）@PostConstruct用于指定初始化方法（用在方法上）@PreDestory用于指定销毁方法（用在方法上）@DependsOn：定义Bean初始化及销毁时的顺序@Primary：自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常@Autowired 默认按类型装配，如果我们想使用按名称装配，可以结合@Qualifier注解一起使用。如下：@Autowired @Qualifier(“personDaoBean”) 存在多个实例配合使用@Resource默认按名称装配，当找不到与名称匹配的bean才会按类型装配。@PostConstruct 初始化注解@PreDestroy 摧毁注解 默认 单例 启动就加载@Async异步方法调用 参考链接：1.https://www.cnblogs.com/xiaoxi/p/5935009.html ​ 2.https://www.cnblogs.com/caijh/p/7744604.html ​ 3.https://www.runoob.com/w3cnote/java-annotation.html","categories":[{"name":"使用参考","slug":"使用参考","permalink":"https://zwf0920.github.io/categories/使用参考/"}],"tags":[{"name":"注解","slug":"注解","permalink":"https://zwf0920.github.io/tags/注解/"}]},{"title":"webpack-dev-server 不是内部或外部命令，也不是可运行的程序 或批处理文件。报错","slug":"vue npm install","date":"2020-02-01T14:56:37.000Z","updated":"2020-02-01T15:06:49.099Z","comments":true,"path":"2020/02/01/vue npm install/","link":"","permalink":"https://zwf0920.github.io/2020/02/01/vue npm install/","excerpt":"","text":"最近把项目拉过来的时候 直接npm install——-npm run dev 一直报错：’webpack-dev-server’ 不是内部或外部命令，也不是可运行的程序 或批处理文件 起初我试着重新装 webpack-dev-server 然而装完之后会有一个一个的依赖接踵而来 都需要装 最后上网查了一顿 找到了一篇不错的文章 第一种方法尝试进行npm install,如果还是不可以就尝试第二种方法，通常是没有装依赖导致的问题。 第二种方法可以通过修改npm的配置文件让npm到另外的pacakge mirror站点去找package，通过如下命令 $ npm config set registry https://registry.npm.taobao.org$ npm config set registry http://r.cnpmjs.org或者：npm config set registry http://registry.npmjs.eu随后再执行npm install然后就可以运行了 参考链接：https://www.cnblogs.com/hanhanours/p/10694692.html","categories":[],"tags":[]},{"title":"什么是javaBean、POJO","slug":"什么是javaBean、POJO","date":"2020-01-27T16:00:00.000Z","updated":"2020-05-10T12:41:49.751Z","comments":true,"path":"2020/01/28/什么是javaBean、POJO/","link":"","permalink":"https://zwf0920.github.io/2020/01/28/什么是javaBean、POJO/","excerpt":"","text":"什么是javaBean、POJO参考资料：https://blog.csdn.net/chenchunlin526/article/details/69939337","categories":[{"name":"小知识","slug":"小知识","permalink":"https://zwf0920.github.io/categories/小知识/"}],"tags":[{"name":"java后端","slug":"java后端","permalink":"https://zwf0920.github.io/tags/java后端/"}]},{"title":"数据量大时分页查询优化方案","slug":"数据量大时分页查询优化方案","date":"2019-08-02T07:36:37.000Z","updated":"2020-05-10T10:06:17.535Z","comments":true,"path":"2019/08/02/数据量大时分页查询优化方案/","link":"","permalink":"https://zwf0920.github.io/2019/08/02/数据量大时分页查询优化方案/","excerpt":"","text":"使用子查询优化使用ID限定优化使用临时表优化临时表用来存储id序列","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://zwf0920.github.io/tags/mysql/"}]},{"title":"MySQL``的作用","slug":"mysql ``的作用","date":"2019-07-27T07:36:37.000Z","updated":"2020-05-09T20:31:33.505Z","comments":true,"path":"2019/07/27/mysql ``的作用/","link":"","permalink":"https://zwf0920.github.io/2019/07/27/mysql ``的作用/","excerpt":"","text":"MySQL``的作用用于转义，某些字段如果是关键字，加上``后可被识别为正常字符","categories":[{"name":"小知识","slug":"小知识","permalink":"https://zwf0920.github.io/categories/小知识/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://zwf0920.github.io/tags/mysql/"}]},{"title":"MySQL底层数据结构总结","slug":"MySQL底层数据结构总结","date":"2019-07-27T07:36:37.000Z","updated":"2020-05-10T10:05:50.918Z","comments":true,"path":"2019/07/27/MySQL底层数据结构总结/","link":"","permalink":"https://zwf0920.github.io/2019/07/27/MySQL底层数据结构总结/","excerpt":"","text":"二叉树很容易形成链表，这样与顺序查询无异 红黑树不支持大数据量存储，数据大的话树的高度也会变大所查询节点在几层就要经过几次磁盘IO Hash表单条查询效率很高范围查询效率低 B-Tree节点横向扩展，控制树的高度一个节点可存储n个数据，n可根据数据量调整 也不支持范围查找 B+树1.非叶子节点不存储data，只存储索引，可以放下更多索引2.叶子姐顶啊不储存指针3.顺序访问指针，提高区域访问的性能叶子节点是完整的，并且以链表链接中间节点冗余范围查找效率高MySql官方设置一个节点容量为16K （约为1170个数据） MyISAM搜索引擎（等待更新） innoDB索引（等待更新）","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://zwf0920.github.io/tags/mysql/"}]},{"title":"","slug":"欢迎使用CSDN-markdown编辑器","date":"2019-07-18T12:42:37.462Z","updated":"2019-07-20T07:37:46.102Z","comments":true,"path":"2019/07/18/欢迎使用CSDN-markdown编辑器/","link":"","permalink":"https://zwf0920.github.io/2019/07/18/欢迎使用CSDN-markdown编辑器/","excerpt":"","text":"@TOC 欢迎来到周炜飞的个人博客","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-07-18T06:16:33.254Z","updated":"2019-07-18T06:16:33.254Z","comments":true,"path":"2019/07/18/hello-world/","link":"","permalink":"https://zwf0920.github.io/2019/07/18/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}